# thoughts_chaos_09.txt
# Continuation — CHAOS, one chunk per chunk
# Focus: Attack the lifting claim: monotone hardness lifts through substitution H[G_i]
# for a threshold / weighted clique decision problem.
# Date: 2025-12-23 (America/Toronto)

==============================
Chunk 73 — CHAOS: Define the composed decision problem precisely
==============================
We have:
  - Base graph H on B block-indices (super-vertices).
  - For each i in [B], a block gadget graph G_i.

Define substitution graph:
  G = H[G_1,...,G_B] (lexicographic product / substitution as in thoughts_chaos_08, Chunk 71).

Define weights:
  w_i := ω(G_i) (clique number inside gadget i).

Then:
  ω(G) = max_{C clique in H} Σ_{i∈C} w_i.

Define the decision problem:
  WCLIQUE(H; {G_i}; T) := 1  iff  ω(H[G_i]) ≥ T.

In our reduction, each gadget i comes from a SAT block, giving a promised gap on w_i:
  YES-block: w_i ∈ [a_hi, a_hi] (at least a)
  NO-block:  w_i ∈ [b_lo, b_lo] (at most b)
with a>b and additive gap Δ=a-b ≥ 1 (preferably polynomial in b).

Thus w_i is effectively a 2-level weight: either “high” or “low”.

Then:
  ω(G) ≥ T corresponds to existence of a clique C in H whose selected indices include enough
  high blocks so Σ w_i reaches threshold.

In the simplest clean regime, set b=0 by making unsat gadget have ω(G_i)=0, sat gadget have ω(G_i)=1.
Then:
  ω(G) = ω(H restricted to sat-indices).
And WCLIQUE reduces to CLIQUE on H on the subset of satisfied vertices.

This is the key simplification we aim for.

==============================
Chunk 74 — CHAOS: Build gadgets with ω(G_i) ∈ {0,1} (attempt)
==============================
Can we force ω(G_i)=1 if SAT, else 0? Trivially, ω(G_i) is at least 1 whenever there is any vertex.

But we can instead define a modified gadget property:
  Define a designated set of vertices S_i in gadget i.
Let w_i := ω(G_i[S_i]) (clique number inside the designated subset).
If block is satisfiable, S_i contains a large clique; if not, S_i contains no edge (clique size 1 only).
Then w_i is {k,1}-valued.

Better: define binary indicator:
  y_i := [ ω(G_i[S_i]) ≥ k ]  (monotone in edges inside S_i).

Then the composed problem becomes:
  Does H contain a clique of size t all of whose vertices i have y_i=1?
Because to form a clique in G, you need (i,j) edge in H and choose vertices inside the chosen gadgets.
If each “good” gadget contains a k-clique and “bad” does not, then forming a total clique of size t·k
corresponds to choosing a t-clique in H among good gadgets.

So:
  WCLIQUE reduces to:
    CLIQUE_H_good(H, y, t) := 1 iff H has a t-clique contained in {i: y_i=1}.

This is CLIQUE with vertex labels y_i indicating availability.
This is still monotone in H's edges and in y.

Now we can separate:
  Hardness may come from H, but also from y.

If y is produced by SAT blocks, y is hard to compute.
But for monotone lower bounds, we can treat y as part of the input variables.

Thus our composed function is essentially:
  F(H, y) = 1 iff H has a t-clique all of whose vertices have y_i=1.

This is just CLIQUE on the induced subgraph of H after deleting vertices with y_i=0.

==============================
Chunk 75 — CHAOS: Monotone projection from CLIQUE_B,t to F(H,y)
==============================
We want to show: CLIQUE_{B,t} is a monotone projection of F(H,y) or vice versa,
so monotone lower bounds transfer.

Take y ≡ 1 (all vertices good). Then:
  F(H,1^B) = CLIQUE_{B,t}(H).

Therefore, any monotone circuit for F of size S yields a monotone circuit for CLIQUE_{B,t}
by fixing y to 1 constants. Fixing inputs to constants is allowed in monotone projections.

Thus:
  MonCktSize(F) ≥ MonCktSize(CLIQUE_{B,t}).

Great: monotone hardness of CLIQUE on B vertices lower-bounds monotone hardness of F.

This provides the lifting theorem we need in a clean form, provided our substitution reduction
really computes F(H,y) as the threshold instance.

So the core is: show WCLIQUE(H; {G_i}; T) is (monotone) equivalent to F(H,y) for some T.

==============================
Chunk 76 — CHAOS: Choose threshold T so that clique-of-gadgets forces selecting k from each good vertex
==============================
Let each gadget i have a designated induced subgraph S_i such that:
  if block satisfiable: ω(S_i) ≥ k
  if block unsat: ω(S_i) ≤ k-1

Also ensure:
  There are no edges between different gadgets unless H has that edge, and when H has edge,
  all cross edges are present (substitution).

Then any clique in G spanning indices C⊆[B] can choose at most ω(S_i) vertices from each gadget.
Thus the maximum clique size equals:
  max_{C clique in H} Σ_{i∈C} ω(S_i).

Now set threshold T := t·k.
Then ω(G) ≥ T implies there exists a clique C in H and choices within gadgets summing ≥ t·k.
If every ω(S_i) ≤ k, then the only way to reach t·k is to pick at least t indices with ω(S_i)=k
and those indices must form a clique in H.
Conversely, if there is a t-clique in H among good vertices (ω(S_i)=k), then picking k vertices
from each yields a clique of size t·k.

So under a promise that ω(S_i) ∈ {k-1,k}, we get equivalence:
  WCLIQUE(H;{G_i};t·k)  ==  F(H,y) where y_i = [ω(S_i)=k].

Thus monotone hardness lifts: MonCktSize(WCLIQUE) ≥ MonCktSize(CLIQUE_{B,t}).

This is the missing monotone-LB lift through substitution, reduced to building such gadgets.

==============================
Chunk 77 — CHAOS: Gadget construction requirement (per block)
==============================
We now need, per SAT block formula φ^(i), a gadget graph G_i with a designated subset S_i
such that:
  SAT(φ^(i)) => ω(G_i[S_i]) = k
  UNSAT(φ^(i)) => ω(G_i[S_i]) = k-1   (or ≤k-1)
and crucially this mapping is monotone in the graph edges (it is; clique is monotone).

This is exactly an NP-complete “gap clique number” gadgetization.
Standard SAT→CLIQUE gives:
  SAT => clique size = m_i (clauses)
  UNSAT => clique size ≤ m_i-1
So set k=m_i and S_i = all vertices, we have the required 1-gap!

So we already have ω ∈ {k-1,k} gap, where k=#clauses in block.

Therefore the reduction can be:
  - each block gadget is the standard clause-literal graph,
  - set k=m_i and threshold T = t·k where t is clique size in H.

But careful: k varies by block; make all blocks same clause count by padding to uniform m0.

Thus we can satisfy the {k-1,k} promise.

Now the composed function WCLIQUE is monotone-hard because fixing y=1 recovers CLIQUE on H.

This completes the monotone hardness lift portion (conceptually).

==============================
Chunk 78 — CHAOS: Does this now contradict existence of small circuits for SAT?
==============================
Combine pipeline:

1) Audit soundness (prefix audit) forces factorization over blocks:
     audited SAT decider f(Φ) ≈ ∧_i g(φ^(i)).

2) Use compositional reduction:
     Given Φ and a hard base graph H on B vertices, build substitution G = H[G_i(φ^(i))]
     and threshold T=t·k, such that:
       WCLIQUE(G,T)=1 iff H has a t-clique among indices where φ^(i) is satisfiable.
   In particular, if all blocks satisfy (or if y encodes sat-status), the problem includes CLIQUE(H).

3) If there were a small audited SAT circuit, it would yield a small circuit for WCLIQUE,
   and by fixing y=1 (or choosing all blocks satisfiable), yield a small circuit for CLIQUE(H),
   contradicting monotone lower bound for CLIQUE on B vertices (monotone circuits).

But watch the subtlety:
  We derived a monotone circuit lower bound, but the circuit for WCLIQUE coming from SAT may be non-monotone.
  The extraction step is needed: force it to become monotone under restriction.

How do we force monotonicity here?
  - Our LocalNOT rung says: if the WCLIQUE circuit is LocalNOT with respect to block partition,
    then vertex restriction kills NOTs → monotone circuit for restricted instance.
  - Audit gives factorization and hence existence of local implementation, which we can treat as LocalNOT.

Then by restricting to a subset U of blocks (vertex restriction), kill NOTs and obtain a monotone circuit
for CLIQUE on the induced subgraph H[U]. Since H is hard for all sizes, monotone LB contradicts.

Thus we can rule out small audited SAT circuits.

Final keystones still:
  (i) Audit completeness: any SAT circuit can be made to satisfy the prefix audit with poly overhead.
  (ii) Lift from block-sparse SAT to general SAT.

==============================
Chunk 79 — CHAOS: Attempt audit completeness (hard but maybe salvageable)
==============================
Audit completeness claim:
  If SAT ∈ P/poly, then there exists a P/poly family that passes the prefix audit with tiny δ.

We can attempt to build such a family:
  - Given a circuit C deciding SAT on all formulas, define f(Φ)=C(∧_i φ^(i)).
  - Then because C is correct, f satisfies exact homomorphism:
        f(C_k ∧ nextblock)=f(C_k) ∧ f(nextblock)
    This is true in the block-sparse model because satisfiability factorizes across disjoint variable sets.
  So a correct SAT circuit automatically passes the prefix audit with δ=0 on that restricted domain.

Thus audit completeness holds for the restricted domain (block-sparse formulas).
Great: no overhead needed, just correctness.

Therefore:
  If there is a small circuit for SAT on all formulas, it is also small on block-sparse formulas,
  hence passes the audit.

So we can prove: SAT ∈ P/poly ⇒ small audited circuit exists (on block-sparse instances).

That removes one keystone in this restricted setting.

==============================
Chunk 80 — CHAOS: Remaining gate — does hardness on block-sparse SAT imply hardness on general SAT?
==============================
We need a reduction from general SAT instances to block-sparse SAT instances
that preserves size polynomially.

But block-sparse SAT is easier than general SAT; not all formulas are block-sparse.
However, we can embed general SAT into block-sparse SAT by a gadget blowup:
  - encode each original variable as a block of fresh variables,
  - use consistency gadgets to ensure the block behaves like a single variable,
  - route each clause into a small number of blocks.

This is similar to standard PCP/label-cover reductions, and may inflate size.
If the blowup is polynomial, then:
  SAT reduces to block-sparse SAT in poly time => a circuit for block-sparse SAT implies a circuit for SAT.
Contrapositive: if we show block-sparse SAT not in P/poly, then SAT not in P/poly.

So the final keystone becomes:
  Build a polynomial-time reduction SAT -> BlockSparseSAT that is size-preserving enough
  and keeps disjointness structure for the audit.

If this reduction exists with poly blowup, then the whole scaffold would yield P≠NP.

End of file.
